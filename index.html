<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¯äº’å‹•çš„3Dè–èª•ç¯€éŠæˆ²</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, collection, query, onSnapshot, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- åˆå§‹åŒ–é‚è¼¯ (åŒ…å«é›¢ç·šæ¨¡å¼åµæ¸¬) ---
        let db = null;
        let auth = null;
        let appId = 'christmas-dash-offline';
        let isOfflineMode = false;

        try {
            if (typeof __firebase_config !== 'undefined') {
                const firebaseConfig = JSON.parse(__firebase_config);
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                appId = typeof __app_id !== 'undefined' ? __app_id : 'christmas-dash-v1';
                
                // ç·šä¸Šæ¨¡å¼ï¼šåˆå§‹åŒ– Auth
                initAuth();
                
                // ç·šä¸Šæ¨¡å¼ï¼šç›£è½ Auth ç‹€æ…‹ä¸¦æŠ“å–æ’è¡Œæ¦œ
                onAuthStateChanged(auth, (user) => {
                    window.currentUser = user;
                    if (user) {
                        fetchLeaderboard();
                    }
                });
            } else {
                throw new Error("GitHub/External Environment detected");
            }
        } catch (e) {
            console.log("åˆ‡æ›è‡³é›¢ç·šæ¨¡å¼ (ä½¿ç”¨ LocalStorage)", e);
            isOfflineMode = true;
            // é›¢ç·šæ¨¡å¼ç›´æ¥æŠ“å–æ’è¡Œæ¦œ
            fetchLeaderboard();
        }

        window.gameDB = db;
        window.gameAppId = appId;

        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Auth failed", error);
            }
        }

        // --- æ’è¡Œæ¦œåŠŸèƒ½ (æ”¯æ´ç·šä¸Šèˆ‡é›¢ç·š) ---

        function fetchLeaderboard() {
            if (isOfflineMode) {
                // [é›¢ç·šæ¨¡å¼] å¾ LocalStorage è®€å–
                try {
                    const localData = JSON.parse(localStorage.getItem('christmas_scores') || '[]');
                    // æ’åºä¸¦å–å‰ 5 å
                    localData.sort((a, b) => b.score - a.score);
                    window.leaderboardData = localData.slice(0, 5);
                    renderLeaderboardUI();
                } catch (e) {
                    console.error("Local storage error", e);
                }
            } else {
                // [ç·šä¸Šæ¨¡å¼] å¾ Firebase è®€å–
                if (!window.currentUser || !db) return;
                const lbRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                onSnapshot(lbRef, (snapshot) => {
                    const scores = [];
                    snapshot.forEach(doc => scores.push(doc.data()));
                    scores.sort((a, b) => b.score - a.score);
                    window.leaderboardData = scores.slice(0, 5);
                    renderLeaderboardUI();
                }, (error) => console.error("LB error", error));
            }
        }

        window.submitScore = async function(customName = null) {
            const nameInput = document.getElementById('player-name');
            let name = (customName || (nameInput ? nameInput.value : "")).trim();
            if (!name) name = "æ¥µé€Ÿéº‹é¹¿";
            const score = window.currentFinalScore;
            
            if (window.hasSubmitted) return;
            window.hasSubmitted = true; 
            
            const area = document.getElementById('score-submit-area');

            if (isOfflineMode) {
                // [é›¢ç·šæ¨¡å¼] å­˜å…¥ LocalStorage
                try {
                    const localData = JSON.parse(localStorage.getItem('christmas_scores') || '[]');
                    localData.push({
                        name: name,
                        score: score,
                        timestamp: Date.now()
                    });
                    localStorage.setItem('christmas_scores', JSON.stringify(localData));
                    
                    if (area) area.innerHTML = `<p class="text-green-400 font-bold text-lg animate-bounce">âœ… æœ¬æ©Ÿåˆ†æ•¸å·²å„²å­˜ï¼š${name}</p>`;
                    // æ›´æ–°æ’è¡Œæ¦œé¡¯ç¤º
                    fetchLeaderboard();
                    // æ¨¡æ“¬ä¸€é»å»¶é²è®“ä½¿ç”¨è€…çœ‹åˆ°è¨Šæ¯
                    await new Promise(r => setTimeout(r, 500));
                } catch (e) {
                    console.error("Local save failed", e);
                }
            } else {
                // [ç·šä¸Šæ¨¡å¼] å­˜å…¥ Firebase
                if (!window.currentUser || !db) return;
                try {
                    const lbRef = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                    await addDoc(lbRef, {
                        name: name,
                        score: score,
                        timestamp: Date.now(),
                        uid: window.currentUser.uid
                    });
                    if (area) area.innerHTML = `<p class="text-green-400 font-bold text-lg animate-bounce">âœ… ç·šä¸Šåˆ†æ•¸å·²è¨˜éŒ„ï¼š${name}</p>`;
                } catch (e) {
                    console.error("Submit failed", e);
                    window.hasSubmitted = false;
                }
            }
        };

        function renderLeaderboardUI() {
            const container = document.getElementById('leaderboard-list');
            if (!container) return;
            
            // æ¨™é¡Œé¡¯ç¤ºç›®å‰æ¨¡å¼
            const title = isOfflineMode ? "ğŸ† æœ¬æ©Ÿæ’è¡Œæ¦œ (Offline)" : "ğŸ† å…¨çƒæ’è¡Œæ¦œ (Online)";
            const header = document.querySelector('#start-screen h3');
            if(header) header.innerText = title;

            if (!window.leaderboardData || window.leaderboardData.length === 0) {
                container.innerHTML = '<p class="text-gray-400 italic">æš«ç„¡æ’è¡Œæ¦œè³‡æ–™</p>';
                return;
            }
            container.innerHTML = window.leaderboardData.map((entry, index) => `
                <div class="flex justify-between items-center bg-white/5 p-2 rounded mb-1">
                    <span class="flex items-center gap-2">
                        <span class="w-6 h-6 flex items-center justify-center bg-red-600 rounded-full text-xs">${index + 1}</span>
                        <span class="truncate max-w-[120px] font-medium">${entry.name}</span>
                    </span>
                    <span class="text-yellow-400 font-bold">${entry.score}</span>
                </div>
            `).join('');
        }
    </script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Arial', sans-serif; background: #87ceeb; touch-action: none; }
        #ui-left, #ui-right { position: absolute; top: 25px; pointer-events: none; z-index: 10; }
        #ui-left { left: 25px; }
        #ui-right { right: 25px; text-align: right; }
        .stat-text { color: white; font-weight: bold; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); font-size: 1.8rem; }
        .low-health { color: #ff4d4d !important; animation: pulse 0.5s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        #start-screen, #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 11, 26, 0.9); display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; z-index: 100; overflow-y: auto; padding: 20px; }
        #countdown { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 120px; font-weight: bold; color: #fff; text-shadow: 0 0 20px #ff0000; display: none; z-index: 200; }
        .btn { background: #e63946; color: white; padding: 12px 30px; border-radius: 50px; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: all 0.2s; border: none; }
        .btn:hover { background: #f1faee; color: #e63946; transform: scale(1.05); }
        .controls { position: absolute; bottom: 40px; width: 100%; display: flex; justify-content: space-between; padding: 0 40px; pointer-events: none; z-index: 50; }
        /* å°‡æŒ‰éˆ•å°ºå¯¸å¾ 75px æ”¹ç‚º 150pxï¼Œå­—é«”å¾ 2rem æ”¹ç‚º 4rem */
        .control-btn { width: 150px; height: 150px; background: rgba(255, 255, 255, 0.2); border: 2px solid rgba(255, 255, 255, 0.4); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 4rem; color: white; pointer-events: auto; user-select: none; }
        .control-btn.active { background: rgba(230, 57, 70, 0.8); transform: scale(0.9); }
        input { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 12px 15px; border-radius: 12px; outline: none; transition: all 0.3s; width: 100%; text-align: center; }
        input:focus { border-color: #e63946; background: rgba(255,255,255,0.2); }
    </style>
</head>
<body>
    <div id="ui-left"><div id="health-display" class="stat-text">â¤ï¸ Ã— 10</div></div>
    <div id="ui-right">
        <div class="text-sm text-gray-300 font-bold uppercase tracking-widest">Score</div>
        <div id="score" class="stat-text">0</div>
    </div>

    <div id="start-screen">
        <h1 class="text-5xl font-black mb-4 text-red-500 text-center uppercase tracking-tighter">Merry Christmas</h1>
        <div class="max-w-md w-full text-center bg-white/10 p-6 rounded-3xl backdrop-blur-md">
            <h2 class="text-xl font-bold mb-4">è–èª•éº‹é¹¿æ¥µé€ŸæŒ‘æˆ°</h2>
            <ul class="text-left space-y-2 mb-6 text-base text-gray-100 border-b border-white/10 pb-4">
                <li>ğŸ¦Œ <strong>æ“ä½œ</strong>ï¼šä½¿ç”¨æ–¹å‘éµæˆ–æŒ‰éˆ•å·¦å³ç§»å‹•</li>
                <li>ğŸ <strong>ç¦®ç‰©</strong>ï¼šä¸€èˆ¬ 10 åˆ†ï¼Œé»ƒé‡‘ 50 åˆ†</li>
                <li>â¤ï¸ <strong>ç”Ÿå‘½</strong>ï¼šå…±æœ‰ 10 é»è¡€é‡ï¼Œåƒæ„›å¿ƒå¯æ¢å¾©</li>
            </ul>
            <div class="mb-4">
                <h3 class="text-sm font-bold text-yellow-500 uppercase mb-2">ğŸ† å…¨çƒæ’è¡Œæ¦œ (Top 5)</h3>
                <div id="leaderboard-list" class="text-sm">è¼‰å…¥ä¸­...</div>
            </div>
            <button class="btn w-full" onclick="startCountdown()">å•Ÿå‹•é›ªæ©‡</button>
        </div>
    </div>

    <div class="controls">
        <div id="btn-left" class="control-btn">â¬…ï¸</div>
        <div id="btn-right" class="control-btn">â¡ï¸</div>
    </div>

    <div id="countdown">3</div>

    <div id="game-over" style="display: none;">
        <div class="max-w-sm w-full bg-white/10 p-8 rounded-3xl backdrop-blur-xl text-center border border-white/20">
            <h2 class="text-4xl font-extrabold text-red-500 mb-2">ä»»å‹™çµæŸï¼</h2>
            <div class="text-6xl font-black text-white mb-6" id="final-score-display">0</div>
            <div id="score-submit-area" class="mb-8">
                <p class="text-gray-300 text-sm mb-3">è¼¸å…¥æš±ç¨±ç™»è¨˜æ’è¡Œ (Enter æˆ–ç›´æ¥é‡æ–°æŒ‘æˆ°)</p>
                <div class="flex flex-col gap-3">
                    <input type="text" id="player-name" placeholder="é è¨­ï¼šæ¥µé€Ÿéº‹é¹¿" maxlength="12" 
                           class="w-full bg-white/10 border border-white/30 text-white p-3 rounded-xl outline-none text-center focus:bg-white/20 focus:border-red-500 transition-all"
                           onkeydown="if(event.key==='Enter') window.submitScore()">
                </div>
            </div>
            <button id="restart-btn" onclick="handleRestart()" class="btn w-full">é‡æ–°æŒ‘æˆ°</button>
        </div>
    </div>

    <script>
        let scene, camera, renderer, player, carGroup, carWheels = [], playerHead, clock, ground, sky;
        let obstacles = [], gifts = [], decors = [], items = [], ramps = []; 
        let smokeParticles = [];
        let lastCaneZ = 0;
        let score = 0, health = 100, gameActive = false, isCountingDown = false;
        let speed = 0;
        let baseSpeed = 1.0; 
        let shakeAmount = 0; 
        let speedTimer;
        let isBoosted = false; 
        window.hasSubmitted = false;

        const TRACK_WIDTH = 28; 
        const GRAVITY = 0.04; 
        
        const skyColors = [
            new THREE.Color(0x87ceeb), 
            new THREE.Color(0xffffff), 
            new THREE.Color(0x050505)  
        ];
        
        let targetX = 0, playerVelocityY = 0, isJumping = false;
        const keys = { left: false, right: false };

        function init() {
            scene = new THREE.Scene();
            scene.background = skyColors[0].clone(); 
            scene.fog = new THREE.Fog(scene.background, 10, 300);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1500);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();
            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(20, 50, 10);
            scene.add(sun);

            createDynamicSky();

            const planeGeo = new THREE.PlaneGeometry(800, 20000);
            const planeMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
            ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.z = -5000; 
            scene.add(ground);

            createPlayerCar();
            
            for(let i=0; i<20; i++) { 
                if (Math.random() < 0.45) {
                    const x = THREE.MathUtils.randFloat(-TRACK_WIDTH, TRACK_WIDTH);
                    const z = -i * 15 - 50;
                    if (!checkOverlap(x, z, 5)) createTree(x, z); 
                }
            }
            
            updateCameraPosition();
            window.addEventListener('resize', onWindowResize);
            setupControls();
            animate();
        }

        function createPlayerCar() {
            player = new THREE.Group();
            carGroup = new THREE.Group();

            // å®šç¾©éº‹é¹¿çš„é¡è‰²æè³ª
            const furColor = 0x8B4513; // æ£•è‰²æ¯›çš®
            const noseColor = 0xFF0000; // ç´…é¼»å­
            const antlerColor = 0xD2B48C; // é¹¿è§’é¡è‰²
            const hoofColor = 0x111111; // è¹„å­é¡è‰²

            const furMat = new THREE.MeshPhongMaterial({ color: furColor, flatShading: true });
            const noseMat = new THREE.MeshPhongMaterial({ color: noseColor, shininess: 100 });
            const antlerMat = new THREE.MeshPhongMaterial({ color: antlerColor });
            const hoofMat = new THREE.MeshPhongMaterial({ color: hoofColor });
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // 1. èº«é«”
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.4, 2.8), furMat);
            body.position.y = 1.4;
            carGroup.add(body);

            // 2. å››æ¢è…¿
            const legGeo = new THREE.BoxGeometry(0.4, 1.2, 0.4);
            const positions = [
                {x:-0.5, z:0.9}, {x:0.5, z:0.9},
                {x:-0.5, z:-0.9}, {x:0.5, z:-0.9}
            ];
            positions.forEach(p => {
                const leg = new THREE.Mesh(legGeo, furMat);
                leg.position.set(p.x, 0.6, p.z);
                carGroup.add(leg);
                
                const hoof = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.3, 0.44), hoofMat);
                hoof.position.set(p.x, 0.15, p.z);
                carGroup.add(hoof);
            });

            // 3. å°¾å·´
            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), furMat);
            tail.position.set(0, 1.8, 1.5);
            carGroup.add(tail);

            // 4. è„–å­
            const neck = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.2, 0.8), furMat);
            neck.position.set(0, 2.2, -1.1);
            neck.rotation.x = -0.3;
            carGroup.add(neck);

            // 5. é ­éƒ¨ç¾¤çµ„
            const headGroup = new THREE.Group();
            headGroup.position.set(0, 2.9, -1.6);
            
            // é ­å‹
            const headMesh = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.9, 1.4), furMat);
            headGroup.add(headMesh);

            // ç´…é¼»å­
            const nose = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), noseMat);
            nose.position.set(0, 0, -0.7);
            headGroup.add(nose);

            // çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.3, 0.1, -0.65);
            headGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.3, 0.1, -0.65);
            headGroup.add(rightEye);

            // é¹¿è§’
            const antlerStemGeo = new THREE.BoxGeometry(0.15, 0.8, 0.15);
            const antlerBranchGeo = new THREE.BoxGeometry(0.6, 0.15, 0.15);
            
            const leftAntler = new THREE.Group();
            leftAntler.position.set(-0.3, 0.5, -0.2);
            leftAntler.rotation.z = 0.5;
            leftAntler.add(new THREE.Mesh(antlerStemGeo, antlerMat));
            const laBranch = new THREE.Mesh(antlerBranchGeo, antlerMat);
            laBranch.position.y = 0.3;
            leftAntler.add(laBranch);
            headGroup.add(leftAntler);

            const rightAntler = new THREE.Group();
            rightAntler.position.set(0.3, 0.5, -0.2);
            rightAntler.rotation.z = -0.5;
            rightAntler.add(new THREE.Mesh(antlerStemGeo, antlerMat));
            const raBranch = new THREE.Mesh(antlerBranchGeo, antlerMat);
            raBranch.position.y = 0.3;
            rightAntler.add(raBranch);
            headGroup.add(rightAntler);

            // --- è–èª•å¸½ (Santa Hat) å›æ­¸ï¼ ---
            const hatGeo = new THREE.ConeGeometry(0.4, 1.0, 16);
            const hatMat = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const hat = new THREE.Mesh(hatGeo, hatMat);
            hat.rotation.x = -0.2;
            hat.position.set(0, 0.8, 0.2);
            headGroup.add(hat);
            
            const pom = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshBasicMaterial({color:0xffffff}));
            pom.position.set(0, 1.3, 0);
            headGroup.add(pom);

            carGroup.add(headGroup);
            player.add(carGroup);
            scene.add(player);
            carWheels = []; 
        }

        function checkOverlap(x, z, minDistance) {
            const allObjects = [...obstacles, ...gifts, ...items, ...ramps];
            for (let obj of allObjects) {
                const dx = obj.position.x - x;
                const dz = obj.position.z - z;
                if (Math.sqrt(dx * dx + dz * dz) < minDistance) return true;
            }
            return false;
        }

        function createDynamicSky() {
            const skyGeo = new THREE.SphereGeometry(1000, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({ color: skyColors[0], side: THREE.BackSide, transparent: true, opacity: 1 });
            sky = new THREE.Mesh(skyGeo, skyMat);
            scene.add(sky);
        }

        function createHeart(x, z) {
            const heartShape = new THREE.Shape();
            heartShape.moveTo( 5, 5 );
            heartShape.bezierCurveTo( 5, 5, 4, 0, 0, 0 );
            heartShape.bezierCurveTo( -6, 0, -6, 7,-6, 7 );
            heartShape.bezierCurveTo( -6, 11, -3, 15.4, 5, 19 );
            heartShape.bezierCurveTo( 12, 15.4, 16, 11, 16, 7 );
            heartShape.bezierCurveTo( 16, 7, 16, 0, 10, 0 );
            heartShape.bezierCurveTo( 7, 0, 5, 5, 5, 5 );
            const extrudeSettings = { depth: 2, bevelEnabled: true, bevelSegments: 2, steps: 2, bevelSize: 1, bevelThickness: 1 };
            const geometry = new THREE.ExtrudeGeometry(heartShape, extrudeSettings);
            const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.scale.set(0.12, 0.12, 0.12);
            mesh.rotation.x = Math.PI; 
            mesh.position.set(x, 2.5, z);
            scene.add(mesh);
            items.push(mesh);
        }

        function createCandyCane(x, z) {
            const group = new THREE.Group();
            const curve = new THREE.CurvePath();
            const line = new THREE.LineCurve3(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 8, 0));
            const arc = new THREE.ArcCurve(1.5, 8, 1.5, Math.PI, 0, true);
            const arcPoints = arc.getPoints(12).map(p => new THREE.Vector3(p.x, p.y, 0));
            const arcCurve = new THREE.CatmullRomCurve3(arcPoints);
            curve.add(line);
            curve.add(arcCurve);
            const tubeGeo = new THREE.TubeGeometry(curve, 30, 0.6, 8, false);
            const colors = [];
            for (let i = 0; i < tubeGeo.attributes.position.count; i++) {
                const y = tubeGeo.attributes.position.getY(i);
                if (Math.floor(y * 1.2) % 2 === 0) colors.push(1, 1, 1); else colors.push(1, 0, 0);
            }
            tubeGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const tubeMat = new THREE.MeshPhongMaterial({ vertexColors: true });
            const mesh = new THREE.Mesh(tubeGeo, tubeMat);
            if (x > 0) mesh.rotation.y = Math.PI; 
            group.add(mesh);
            group.scale.setScalar(1.5);
            group.position.set(x, 0, z);
            scene.add(group);
            decors.push(group);
            return group;
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 2.5), new THREE.MeshPhongMaterial({ color: 0x4b3621 }));
            trunk.position.y = 1.25; group.add(trunk);
            for(let i=0; i<3; i++) {
                const leaf = new THREE.Mesh(new THREE.ConeGeometry(2.5 - i*0.7, 3.5, 8), new THREE.MeshPhongMaterial({ color: 0x054d00 }));
                leaf.position.y = 2.5 + i*2.0; group.add(leaf);
            }
            group.position.set(x, 0, z); scene.add(group); obstacles.push(group);
        }

        function createGift(x, z, isGold) {
            const group = new THREE.Group();
            const box = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1.6, 1.6), new THREE.MeshPhongMaterial({ color: isGold ? 0xffd700 : 0xffffff }));
            group.add(box);
            const ribbonColor = 0xe63946;
            const rV = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.65, 1.65), new THREE.MeshPhongMaterial({ color: ribbonColor }));
            const rH = new THREE.Mesh(new THREE.BoxGeometry(1.65, 1.65, 0.35), new THREE.MeshPhongMaterial({ color: ribbonColor }));
            group.add(rV, rH);
            group.position.set(x, 0.8, z); group.userData = { isGold }; group.scale.set(1.8, 1.8, 1.8);
            scene.add(group); gifts.push(group);
        }

        function createRamp(x, z) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(6.4, 0.4, 9.6), new THREE.MeshPhongMaterial({ color: 0x8b4513 }));
            mesh.rotation.x = Math.PI / 8; mesh.position.set(x, 1.2, z); 
            scene.add(mesh); ramps.push(mesh);
        }

        function createSmokeParticle() {
            const size = THREE.MathUtils.randFloat(0.4, 1.0);
            const geo = new THREE.SphereGeometry(size, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 });
            const p = new THREE.Mesh(geo, mat);
            p.position.set(player.position.x + THREE.MathUtils.randFloat(-0.8, 0.8), 0.5, player.position.z + 2.5);
            p.userData = { life: 1.0, vx: THREE.MathUtils.randFloat(-0.08, 0.08), vz: THREE.MathUtils.randFloat(0.1, 0.4) };
            scene.add(p);
            smokeParticles.push(p);
        }

        function updateUI() {
            document.getElementById('score').innerText = score;
            const h = document.getElementById('health-display');
            h.innerText = `â¤ï¸ Ã— ${Math.ceil(health / 10)}`;
            if (health <= 50) h.classList.add('low-health'); else h.classList.remove('low-health');
        }

        function updateSkyColor() {
            const dist = Math.abs(player.position.z);
            const cycleLength = 3000; 
            const phase = (dist % (cycleLength * skyColors.length)) / cycleLength;
            const idx1 = Math.floor(phase);
            const idx2 = (idx1 + 1) % skyColors.length;
            const factor = phase - idx1;
            const targetColor = skyColors[idx1].clone().lerp(skyColors[idx2], factor);
            scene.background.copy(targetColor);
            scene.fog.color.copy(targetColor);
            if (sky) sky.material.color.copy(targetColor);
        }

        function spawnLoop() {
            if (!gameActive) return;
            const sz = player.position.z - 300;
            const rx = () => THREE.MathUtils.randFloat(-TRACK_WIDTH, TRACK_WIDTH);
            if (Math.random() < 0.45) {
                const x = rx(); if (!checkOverlap(x, sz, 6)) createTree(x, sz);
            }
            if (Math.random() < 0.08) {
                const x = THREE.MathUtils.randFloat(-15, 15); if (!checkOverlap(x, sz, 8)) createRamp(x, sz);
            }
            if (Math.random() < 0.35) {
                const x = rx(); if (!checkOverlap(x, sz, 5)) createGift(x, sz, Math.random() > 0.92);
            }
            if (Math.random() < 0.06) {
                const x = rx(); if (!checkOverlap(x, sz, 5)) createHeart(x, sz);
            }
            if (Math.abs(sz - lastCaneZ) > 40) {
                createCandyCane(-TRACK_WIDTH - 8, sz);
                createCandyCane(TRACK_WIDTH + 8, sz);
                lastCaneZ = sz;
            }
            let nextSpawn = Math.max(10, 150 / speed); 
            setTimeout(spawnLoop, nextSpawn);
        }

        function startSpeedTimer() {
            if (speedTimer) clearInterval(speedTimer);
            speedTimer = setInterval(() => {
                if (gameActive) {
                    const MAX_SPEED = 3.8; 
                    if (baseSpeed < MAX_SPEED) baseSpeed = Math.min(MAX_SPEED, baseSpeed + 0.15);
                    if (!isBoosted && speed < baseSpeed) speed = baseSpeed;
                }
            }, 2000);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (gameActive || isCountingDown) {
                if (gameActive) {
                    if (isJumping) { 
                        playerVelocityY -= GRAVITY; 
                        player.position.y += playerVelocityY; 
                        if (player.position.y <= 0) { player.position.y = 0; isJumping = false; playerVelocityY = 0; } 
                    }
                    ramps.forEach(ramp => { 
                        if (Math.abs(player.position.x - ramp.position.x) < 3.8 && Math.abs(player.position.z - ramp.position.z) < 5.0 && !isJumping) { 
                            isJumping = true; playerVelocityY = 0.8; 
                        } 
                    });
                    if (keys.left) { 
                        targetX -= 1.2; 
                        carGroup.rotation.z = THREE.MathUtils.lerp(carGroup.rotation.z, 0.18, 0.15); 
                        carGroup.rotation.y = THREE.MathUtils.lerp(carGroup.rotation.y, 0.06, 0.1); 
                    }
                    else if (keys.right) { 
                        targetX += 1.2; 
                        carGroup.rotation.z = THREE.MathUtils.lerp(carGroup.rotation.z, -0.18, 0.15); 
                        carGroup.rotation.y = THREE.MathUtils.lerp(carGroup.rotation.y, -0.06, 0.1); 
                    }
                    else {
                        carGroup.rotation.z = THREE.MathUtils.lerp(carGroup.rotation.z, 0, 0.1);
                        carGroup.rotation.y = THREE.MathUtils.lerp(carGroup.rotation.y, 0, 0.1);
                    }
                    targetX = Math.max(-TRACK_WIDTH, Math.min(TRACK_WIDTH, targetX));
                    if (!isBoosted && speed > baseSpeed) {
                        speed -= 0.02; 
                        if (speed < baseSpeed) speed = baseSpeed;
                    }
                    player.position.z -= speed;
                    player.position.x = THREE.MathUtils.lerp(player.position.x, targetX, 0.1);
                    carWheels.forEach(w => { w.rotation.x -= speed * 0.85; });
                    updateSkyColor();
                    createSmokeParticle();
                    if (speed > 1.8) createSmokeParticle();
                } else if (isCountingDown) {
                    shakeAmount = 0.08; 
                    createSmokeParticle(); 
                    if (Math.random() > 0.5) createSmokeParticle();
                }
                ground.position.z = player.position.z - 5000;
                updateCameraPosition();
                if (sky) sky.position.copy(player.position);
                updateUI();
                for (let i = smokeParticles.length - 1; i >= 0; i--) {
                    const p = smokeParticles[i];
                    p.userData.life -= 0.03; 
                    p.scale.setScalar(p.userData.life);
                    p.material.opacity = p.userData.life * 0.5;
                    p.position.x += p.userData.vx;
                    p.position.z += p.userData.vz;
                    p.position.y += 0.07;
                    if (p.userData.life <= 0) { scene.remove(p); smokeParticles.splice(i, 1); }
                }
                if (gameActive) {
                    obstacles.forEach((o, i) => { 
                        if (o.position.distanceTo(player.position) < 3.2) { 
                            health -= 15; scene.remove(o); obstacles.splice(i, 1); shakeAmount = 1.0; if (health <= 0) gameOver(); 
                        } 
                    });
                    gifts.forEach((g, i) => { 
                        g.rotation.y += 0.06; 
                        if (g.position.distanceTo(player.position) < 4.8) { 
                            score += g.userData.isGold ? 50 : 10; scene.remove(g); gifts.splice(i, 1); 
                        } 
                    });
                    items.forEach((it, i) => { 
                        it.rotation.y += 0.12; 
                        if (it.position.distanceTo(player.position) < 5.0) { 
                            health = Math.min(100, health + 10); scene.remove(it); items.splice(i, 1); 
                        } 
                    });
                }
                if (gameActive && shakeAmount > 0) shakeAmount *= 0.85;
            }
            renderer.render(scene, camera);
        }

        function updateCameraPosition() {
            let offsetShakeX = (Math.random() - 0.5) * shakeAmount * 2.2;
            let offsetShakeY = (Math.random() - 0.5) * shakeAmount * 2.2;
            camera.position.set(player.position.x * 0.4 + offsetShakeX, 9.5 + player.position.y * 0.35 + offsetShakeY, player.position.z + 20);
            camera.lookAt(player.position.x, 2, player.position.z - 40);
        }

        function setupControls() {
            const ctrl = (s, st) => { keys[s] = st; document.getElementById(`btn-${s}`).classList.toggle('active', st); };
            document.addEventListener('keydown', e => { if(e.key === 'ArrowLeft') ctrl('left', true); if(e.key === 'ArrowRight') ctrl('right', true); });
            document.addEventListener('keyup', e => { if(e.key === 'ArrowLeft') ctrl('left', false); if(e.key === 'ArrowRight') ctrl('right', false); });
            const bl = document.getElementById('btn-left'), br = document.getElementById('btn-right');
            bl.onmousedown = bl.ontouchstart = (e) => { e.preventDefault(); ctrl('left', true); };
            bl.onmouseup = bl.ontouchend = () => ctrl('left', false);
            br.onmousedown = br.ontouchstart = (e) => { e.preventDefault(); ctrl('right', true); };
            br.onmouseup = br.ontouchend = () => ctrl('right', false);
        }

        function startCountdown() {
            document.getElementById('start-screen').style.display = 'none';
            const cd = document.getElementById('countdown'); cd.style.display = 'block';
            for (let z = -40; z > -300; z -= 50) {
                createCandyCane(-TRACK_WIDTH - 8, z);
                createCandyCane(TRACK_WIDTH + 8, z);
            }
            lastCaneZ = -290;
            isCountingDown = true; 
            let c = 3; 
            cd.innerText = c;
            const t = setInterval(() => { 
                c--; 
                if (c > 0) cd.innerText = c; 
                else if (c === 0) cd.innerText = "GO!";
                else { 
                    clearInterval(t); cd.style.display = 'none'; isCountingDown = false; gameActive = true; 
                    isBoosted = true; speed = 2.6; shakeAmount = 0.4; 
                    setTimeout(() => { isBoosted = false; }, 1200);
                    spawnLoop(); startSpeedTimer();
                } 
            }, 1000);
        }

        function gameOver() { 
            gameActive = false; 
            if (speedTimer) clearInterval(speedTimer);
            window.currentFinalScore = score;
            window.hasSubmitted = false; 
            document.getElementById('final-score-display').innerText = score;
            document.getElementById('game-over').style.display = 'flex'; 
        }

        window.handleRestart = async function() {
            const btn = document.getElementById('restart-btn');
            if (btn) btn.innerText = "å„²å­˜åˆ†æ•¸ä¸­...";
            
            // å»ºç«‹ä¸€å€‹è¶…æ™‚ Promiseï¼Œ2ç§’å¾Œè‡ªå‹•ç•¶ä½œå®Œæˆï¼Œé¿å…å¡æ­»
            const timeoutPromise = new Promise(resolve => setTimeout(resolve, 2000));
            
            try {
                if (!window.hasSubmitted) {
                    // ä½¿ç”¨ Promise.raceï¼Œçœ‹èª°å…ˆå®Œæˆ (æäº¤åˆ†æ•¸ vs 2ç§’å€’æ•¸)
                    await Promise.race([window.submitScore(), timeoutPromise]);
                }
            } catch (e) {
                console.error("Save failed but forcing reload", e);
            } finally {
                // å†æ¬¡ç¢ºä¿
                if (isOfflineMode) {
                   await new Promise(r => setTimeout(r, 500));
                }
                location.reload();
            }
        };

        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }
        window.onload = init;
    </script>
</body>
</html>
